// Claude Monitor Dashboard Server
// Receives monitoring data from the unified-claude-monitor.sh script

const express = require('express');
const cors = require('cors');
const WebSocket = require('ws');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');
const http = require('http');

// Configuration
const PORT = process.env.PORT || 3001;
const DB_PATH = path.join(__dirname, 'claude-monitor.db');

// Initialize Express app
const app = express();
const server = http.createServer(app);

// Initialize WebSocket server
const wss = new WebSocket.Server({ server });

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Initialize SQLite database
const db = new sqlite3.Database(DB_PATH);

// Create tables if they don't exist
db.serialize(() => {
    // Activity table for all events
    db.run(`
        CREATE TABLE IF NOT EXISTS activity (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            source TEXT NOT NULL,
            type TEXT NOT NULL,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            data TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);

    // Metrics table for aggregated data
    db.run(`
        CREATE TABLE IF NOT EXISTS metrics (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            metric_name TEXT NOT NULL,
            metric_value REAL NOT NULL,
            source TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);

    // Sessions table for Claude Code sessions
    db.run(`
        CREATE TABLE IF NOT EXISTS sessions (
            session_id TEXT PRIMARY KEY,
            project TEXT,
            started_at DATETIME,
            last_activity DATETIME,
            message_count INTEGER DEFAULT 0,
            token_count INTEGER DEFAULT 0
        )
    `);
});

// Store active WebSocket connections
const clients = new Set();

// WebSocket connection handler
wss.on('connection', (ws) => {
    console.log('New WebSocket client connected');
    clients.add(ws);
    
    // Send current stats to new client
    sendCurrentStats(ws);
    
    ws.on('close', () => {
        console.log('Client disconnected');
        clients.delete(ws);
    });
    
    ws.on('error', (error) => {
        console.error('WebSocket error:', error);
    });
});

// Broadcast to all connected clients
function broadcast(data) {
    const message = JSON.stringify(data);
    clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
            client.send(message);
        }
    });
}

// Send current stats to a client
async function sendCurrentStats(ws) {
    const stats = await getStats();
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'stats',
            data: stats
        }));
    }
}

// Get statistics from database
function getStats() {
    return new Promise((resolve, reject) => {
        const stats = {
            totalActivities: 0,
            recentActivities: [],
            sessionCount: 0,
            todayActivities: 0,
            sources: {}
        };
        
        // Get total activities
        db.get('SELECT COUNT(*) as count FROM activity', (err, row) => {
            if (err) return reject(err);
            stats.totalActivities = row.count;
            
            // Get today's activities
            db.get(`
                SELECT COUNT(*) as count FROM activity 
                WHERE date(timestamp) = date('now')
            `, (err, row) => {
                if (err) return reject(err);
                stats.todayActivities = row.count;
                
                // Get recent activities
                db.all(`
                    SELECT * FROM activity 
                    ORDER BY timestamp DESC 
                    LIMIT 10
                `, (err, rows) => {
                    if (err) return reject(err);
                    stats.recentActivities = rows;
                    
                    // Get activity by source
                    db.all(`
                        SELECT source, COUNT(*) as count 
                        FROM activity 
                        GROUP BY source
                    `, (err, rows) => {
                        if (err) return reject(err);
                        rows.forEach(row => {
                            stats.sources[row.source] = row.count;
                        });
                        
                        resolve(stats);
                    });
                });
            });
        });
    });
}

// API Routes

// Receive activity data from monitors
app.post('/api/activity', (req, res) => {
    const { source, type, timestamp, data } = req.body;
    
    console.log(`[${source}] ${type} at ${timestamp}`);
    
    // Store in database
    db.run(
        'INSERT INTO activity (source, type, timestamp, data) VALUES (?, ?, ?, ?)',
        [source, type, timestamp || new Date().toISOString(), JSON.stringify(data)],
        function(err) {
            if (err) {
                console.error('Database error:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            
            // Broadcast to WebSocket clients
            broadcast({
                type: 'new_activity',
                activity: {
                    id: this.lastID,
                    source,
                    type,
                    timestamp,
                    data
                }
            });
            
            res.json({ 
                success: true, 
                id: this.lastID,
                message: 'Activity recorded'
            });
        }
    );
});

// Get statistics
app.get('/api/stats', async (req, res) => {
    try {
        const stats = await getStats();
        res.json(stats);
    } catch (error) {
        console.error('Error getting stats:', error);
        res.status(500).json({ error: 'Failed to get statistics' });
    }
});

// Get recent activities
app.get('/api/activities', (req, res) => {
    const limit = parseInt(req.query.limit) || 100;
    const offset = parseInt(req.query.offset) || 0;
    
    db.all(
        'SELECT * FROM activity ORDER BY timestamp DESC LIMIT ? OFFSET ?',
        [limit, offset],
        (err, rows) => {
            if (err) {
                console.error('Database error:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            
            // Parse JSON data field
            rows.forEach(row => {
                try {
                    row.data = JSON.parse(row.data);
                } catch (e) {
                    // Keep as string if not valid JSON
                }
            });
            
            res.json(rows);
        }
    );
});

// Get metrics
app.get('/api/metrics', (req, res) => {
    const since = req.query.since || new Date(Date.now() - 24*60*60*1000).toISOString();
    
    db.all(
        'SELECT * FROM metrics WHERE timestamp > ? ORDER BY timestamp DESC',
        [since],
        (err, rows) => {
            if (err) {
                console.error('Database error:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            res.json(rows);
        }
    );
});

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        connections: clients.size,
        database: DB_PATH
    });
});

// Start server
server.listen(PORT, () => {
    console.log(`
    ╔══════════════════════════════════════════╗
    ║   Claude Monitor Dashboard Server        ║
    ╠══════════════════════════════════════════╣
    ║   🚀 Server running on port ${PORT}         ║
    ║   📊 Dashboard: http://localhost:${PORT}    ║
    ║   🔌 WebSocket: ws://localhost:${PORT}      ║
    ║   💾 Database: ${path.basename(DB_PATH)}             ║
    ╚══════════════════════════════════════════╝
    
    API Endpoints:
    • POST /api/activity     - Receive monitor data
    • GET  /api/stats        - Get statistics
    • GET  /api/activities   - Get recent activities
    • GET  /api/metrics      - Get metrics
    • GET  /health           - Health check
    
    WebSocket events:
    • new_activity - Real-time activity updates
    • stats        - Statistics updates
    `);
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('\n🛑 Shutting down dashboard server...');
    
    // Close WebSocket connections
    clients.forEach(client => client.close());
    
    // Close database
    db.close((err) => {
        if (err) console.error('Error closing database:', err);
        console.log('✅ Dashboard server stopped');
        process.exit(0);
    });
});
