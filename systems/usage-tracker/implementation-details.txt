# Claude Token Usage Logger for Vibe Coders

## 🎯 Project Overview

**Mission**: Create a comprehensive token usage logging system that helps Vibe Coders maximize their Claude usage across all platforms while staying within weekly limits.

**Target Users**: Max Plan subscribers using Claude Desktop, Claude Code, and web interface
**Key Constraint**: Weekly rate limits starting August 28, 2025
**Primary Goal**: Precision planning and execution to maximize value within constraints

## 📊 System Architecture

### Core Components

#### 1. Universal Token Tracker
- **Cross-platform monitoring**: Claude Desktop, Claude Code, Web Interface
- **Real-time calculation**: Token estimation with each prompt
- **Session awareness**: 5-hour block tracking
- **Weekly aggregation**: Rolling 7-day usage windows

#### 2. Usage Database Schema

```sql
-- Core usage tracking table
CREATE TABLE claude_usage_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT NOT NULL,
    platform TEXT NOT NULL, -- 'desktop', 'code', 'web'
    model_used TEXT NOT NULL, -- 'sonnet-4', 'opus-4'
    prompt_tokens INTEGER NOT NULL,
    completion_tokens INTEGER NOT NULL,
    total_tokens INTEGER NOT NULL,
    estimated_cost_usd REAL NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    project_context TEXT,
    session_type TEXT, -- 'planning', 'coding', 'testing', 'review'
    efficiency_score REAL DEFAULT 0
);

-- Session blocks tracking (5-hour limits)
CREATE TABLE session_blocks (
    session_id TEXT PRIMARY KEY,
    start_time DATETIME NOT NULL,
    end_time DATETIME,
    platform TEXT NOT NULL,
    total_tokens INTEGER DEFAULT 0,
    total_cost_usd REAL DEFAULT 0,
    status TEXT DEFAULT 'active', -- 'active', 'completed', 'interrupted'
    project_path TEXT,
    goals TEXT,
    achievements TEXT
);

-- Weekly quota tracking
CREATE TABLE weekly_quotas (
    week_start DATE PRIMARY KEY,
    sonnet_tokens_used INTEGER DEFAULT 0,
    opus_tokens_used INTEGER DEFAULT 0,
    sonnet_hours_equivalent REAL DEFAULT 0,
    opus_hours_equivalent REAL DEFAULT 0,
    total_cost_usd REAL DEFAULT 0,
    sessions_count INTEGER DEFAULT 0,
    efficiency_average REAL DEFAULT 0
);
```

#### 3. Token Estimation Engine

```python
class TokenEstimator:
    """Estimate token usage before sending prompts"""
    
    def __init__(self):
        self.model_costs = {
            'sonnet-4': {'input': 0.003, 'output': 0.015},  # per 1k tokens
            'opus-4': {'input': 0.015, 'output': 0.075}
        }
        
    def estimate_prompt_tokens(self, text: str) -> int:
        """Rough estimation: ~4 chars per token"""
        return len(text) // 4
    
    def estimate_session_cost(self, prompts: list, model: str) -> dict:
        """Estimate total cost for a planned session"""
        total_input = sum(self.estimate_prompt_tokens(p) for p in prompts)
        estimated_output = total_input * 0.7  # Conservative estimate
        
        input_cost = (total_input / 1000) * self.model_costs[model]['input']
        output_cost = (estimated_output / 1000) * self.model_costs[model]['output']
        
        return {
            'estimated_tokens': total_input + estimated_output,
            'estimated_cost': input_cost + output_cost,
            'input_tokens': total_input,
            'output_tokens': estimated_output
        }
```

## 🔄 Cross-Platform Integration

### 1. Claude Desktop Integration

```python
class ClaudeDesktopMonitor:
    """Monitor Claude Desktop usage through system hooks"""
    
    def __init__(self, logger):
        self.logger = logger
        self.current_session = None
        
    def start_session_tracking(self, project_context=""):
        """Begin tracking a new Claude Desktop session"""
        self.current_session = {
            'session_id': f"desktop_{uuid.uuid4().hex[:8]}",
            'start_time': datetime.now(),
            'platform': 'desktop',
            'project_context': project_context,
            'prompts': []
        }
        
        return self.current_session['session_id']
    
    def log_prompt(self, prompt_text: str, response_text: str, model: str):
        """Log each prompt/response pair"""
        if not self.current_session:
            self.start_session_tracking()
            
        prompt_tokens = self.estimate_tokens(prompt_text)
        response_tokens = self.estimate_tokens(response_text)
        
        usage_entry = {
            'session_id': self.current_session['session_id'],
            'platform': 'desktop',
            'model_used': model,
            'prompt_tokens': prompt_tokens,
            'completion_tokens': response_tokens,
            'total_tokens': prompt_tokens + response_tokens,
            'estimated_cost_usd': self.calculate_cost(prompt_tokens, response_tokens, model),
            'project_context': self.current_session['project_context']
        }
        
        self.logger.log_usage(usage_entry)
        self.current_session['prompts'].append(usage_entry)
```

### 2. Claude Code Integration

```python
class ClaudeCodeMonitor:
    """Enhanced monitoring for Claude Code sessions"""
    
    def __init__(self, logger):
        self.logger = logger
        self.wrapper = ClaudeCodeWrapper(self)
        
    def wrap_claude_code_session(self, project_path: str, session_type: str):
        """Wrap Claude Code execution with detailed logging"""
        
        session_id = f"code_{uuid.uuid4().hex[:8]}"
        
        # Pre-session analysis
        project_analysis = self.analyze_project_complexity(project_path)
        estimated_usage = self.estimate_session_requirements(project_analysis, session_type)
        
        # Check quota availability
        if not self.check_quota_availability(estimated_usage):
            raise QuotaExhaustedException("Insufficient quota for planned session")
        
        # Start session tracking
        session_data = {
            'session_id': session_id,
            'start_time': datetime.now(),
            'platform': 'code',
            'project_path': project_path,
            'session_type': session_type,
            'estimated_tokens': estimated_usage['tokens'],
            'estimated_cost': estimated_usage['cost']
        }
        
        return self.wrapper.execute_with_monitoring(session_data)
```

### 3. Web Interface Integration

```javascript
// Browser extension for web interface monitoring
class ClaudeWebMonitor {
    constructor() {
        this.sessionId = null;
        this.promptCount = 0;
        this.startTime = null;
    }
    
    startMonitoring() {
        this.sessionId = `web_${this.generateId()}`;
        this.startTime = new Date();
        this.promptCount = 0;
        
        // Hook into Claude web interface
        this.observePrompts();
        this.observeResponses();
    }
    
    observePrompts() {
        // Monitor for new prompts in the web interface
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList') {
                    const newPrompts = mutation.target.querySelectorAll('[data-testid="user-message"]');
                    newPrompts.forEach(prompt => this.logPrompt(prompt));
                }
            });
        });
        
        observer.observe(document.body, { childList: true, subtree: true });
    }
    
    logPrompt(promptElement) {
        const promptText = promptElement.textContent;
        const tokens = this.estimateTokens(promptText);
        
        // Send to logging backend
        this.sendToLogger({
            sessionId: this.sessionId,
            platform: 'web',
            promptTokens: tokens,
            timestamp: new Date().toISOString(),
            promptNumber: ++this.promptCount
        });
    }
}
```

## 📅 Calendar Integration for Session Planning

### Smart Session Scheduler

```python
class VibeCoderScheduler:
    """Plan optimal coding sessions within quota constraints"""
    
    def __init__(self, usage_logger, calendar_service):
        self.logger = usage_logger
        self.calendar = calendar_service
        
    def plan_development_phase(self, project_analysis: dict, deadline: datetime):
        """Create optimized development schedule"""
        
        # Calculate available quota
        weekly_usage = self.logger.get_weekly_usage()
        available_quota = self.calculate_available_quota(weekly_usage)
        
        # Break down development phases
        phases = self.break_down_development(project_analysis)
        
        # Optimize phase scheduling
        schedule = self.optimize_schedule(phases, available_quota, deadline)
        
        # Create calendar blocks
        calendar_blocks = []
        for phase in schedule:
            block = {
                'title': f"Claude Code: {phase['type']} - {project_analysis['name']}",
                'start': phase['start_time'],
                'end': phase['end_time'],
                'description': f"""
                🚀 Vibe Coder Session
                
                Phase: {phase['type']}
                Estimated tokens: {phase['estimated_tokens']:,}
                Estimated cost: ${phase['estimated_cost']:.2f}
                Model: {phase['recommended_model']}
                
                Goals:
                {chr(10).join(f"• {goal}" for goal in phase['goals'])}
                
                Quota Check:
                Sonnet remaining: {available_quota['sonnet_hours']:.1f}h
                Opus remaining: {available_quota['opus_hours']:.1f}h
                """,
                'color': self.get_phase_color(phase['type'])
            }
            calendar_blocks.append(block)
            
        return self.calendar.create_blocks(calendar_blocks)
```

## 📊 Real-Time Monitoring Dashboard

### Usage Dashboard Components

```python
class VibeCoderDashboard:
    """Real-time usage monitoring for Vibe Coders"""
    
    def get_current_status(self) -> dict:
        """Get current usage status across all platforms"""
        
        # Current session status
        active_sessions = self.get_active_sessions()
        
        # Weekly quota status
        weekly_usage = self.get_weekly_usage()
        quota_status = self.calculate_quota_status(weekly_usage)
        
        # Efficiency metrics
        efficiency = self.calculate_current_efficiency()
        
        return {
            'active_sessions': {
                'count': len(active_sessions),
                'platforms': [s['platform'] for s in active_sessions],
                'total_duration': sum(s['duration_minutes'] for s in active_sessions),
                'estimated_remaining_time': self.estimate_remaining_session_time()
            },
            'weekly_status': {
                'sonnet_usage': {
                    'hours_used': weekly_usage['sonnet_hours'],
                    'limit': 480,  # Max plan
                    'percentage': (weekly_usage['sonnet_hours'] / 480) * 100,
                    'hours_remaining': 480 - weekly_usage['sonnet_hours']
                },
                'opus_usage': {
                    'hours_used': weekly_usage['opus_hours'],
                    'limit': 40,   # Max plan
                    'percentage': (weekly_usage['opus_hours'] / 40) * 100,
                    'hours_remaining': 40 - weekly_usage['opus_hours']
                }
            },
            'efficiency': {
                'current_session': efficiency['current'],
                'weekly_average': efficiency['weekly_avg'],
                'improvement_trend': efficiency['trend']
            },
            'recommendations': self.get_usage_recommendations(quota_status)
        }
```

## 🚨 Smart Alerts and Warnings

### Proactive Quota Management

```python
class QuotaAlertSystem:
    """Proactive alerts to prevent quota exhaustion"""
    
    def __init__(self, logger, notification_service):
        self.logger = logger
        self.notifications = notification_service
        
    def check_quota_alerts(self):
        """Check for quota situations requiring alerts"""
        
        weekly_usage = self.logger.get_weekly_usage()
        alerts = []
        
        # Weekly limit warnings
        sonnet_percentage = (weekly_usage['sonnet_hours'] / 480) * 100
        opus_percentage = (weekly_usage['opus_hours'] / 40) * 100
        
        if sonnet_percentage > 80:
            alerts.append({
                'type': 'warning',
                'priority': 'high',
                'message': f"Sonnet usage at {sonnet_percentage:.1f}% of weekly limit",
                'recommendation': "Consider switching to more efficient workflows",
                'action': "review_usage_patterns"
            })
            
        if opus_percentage > 70:
            alerts.append({
                'type': 'critical',
                'priority': 'urgent',
                'message': f"Opus usage at {opus_percentage:.1f}% of weekly limit",
                'recommendation': "Reserve remaining Opus for critical tasks only",
                'action': "switch_to_sonnet"
            })
        
        # Session duration warnings
        active_sessions = self.get_active_sessions()
        for session in active_sessions:
            if session['duration_hours'] > 4.5:
                alerts.append({
                    'type': 'session_warning',
                    'priority': 'medium',
                    'message': f"Session approaching 5-hour limit in {session['platform']}",
                    'recommendation': "Save progress and prepare for session break",
                    'action': "prepare_session_break"
                })
        
        return alerts
```

## 🛠️ CLI Tools for Vibe Coders

### Command Line Interface

```bash
# Core usage commands
vibe-logger status                    # Current usage across all platforms
vibe-logger weekly-report            # Comprehensive weekly analysis
vibe-logger plan-session coding 4h   # Plan a 4-hour coding session
vibe-logger quota-check opus         # Check Opus quota availability

# Session management
vibe-logger start-session desktop    # Start tracking desktop session
vibe-logger end-session abc123       # End specific session
vibe-logger session-summary abc123   # Get session efficiency report

# Planning commands
vibe-logger analyze-project /path    # Analyze project complexity
vibe-logger schedule-week            # Generate weekly schedule
vibe-logger calendar-sync            # Sync with Google Calendar

# Emergency commands
vibe-logger emergency-save           # Save current session state
vibe-logger quota-emergency         # Handle quota exhaustion
```

## 🎯 Implementation Roadmap

### Phase 1: Core Logging Infrastructure (Week 1-2)
- [ ] Database schema implementation
- [ ] Basic token estimation engine
- [ ] Claude Desktop monitoring
- [ ] CLI foundation

### Phase 2: Cross-Platform Integration (Week 3-4)
- [ ] Claude Code wrapper enhancement
- [ ] Web interface browser extension
- [ ] Real-time synchronization
- [ ] Session management system

### Phase 3: Intelligence Layer (Week 5-6)
- [ ] Usage pattern analysis
- [ ] Efficiency scoring algorithms
- [ ] Predictive quota management
- [ ] Smart alert system

### Phase 4: Calendar & Planning (Week 7-8)
- [ ] Google Calendar integration
- [ ] Automated session scheduling
- [ ] Project complexity analysis
- [ ] iCal export functionality

### Phase 5: Dashboard & UX (Week 9-10)
- [ ] Real-time dashboard
- [ ] Mobile notifications
- [ ] Team coordination features
- [ ] Advanced analytics

## 📈 Success Metrics

### User Experience Goals
- **95% accuracy** in token usage estimation
- **<1 second** response time for status queries
- **Zero quota surprises** through proactive alerts
- **50% improvement** in session efficiency

### Technical Performance
- **Real-time synchronization** across all platforms
- **99.9% uptime** for monitoring systems
- **Cross-platform compatibility** (macOS, Windows, Linux)
- **Seamless integration** with existing workflows

## 🚀 Getting Started

### Quick Setup for Vibe Coders

1. **Install the logger**:
   ```bash
   pip install vibe-claude-logger
   vibe-logger setup --plan max
   ```

2. **Connect platforms**:
   ```bash
   vibe-logger connect desktop
   vibe-logger connect code
   vibe-logger install-browser-extension
   ```

3. **Start monitoring**:
   ```bash
   vibe-logger start-monitoring
   vibe-logger status
   ```

4. **Plan your first optimized session**:
   ```bash
   vibe-logger plan-session coding 4h --project ./my-app
   ```

## 💡 Pro Tips for Vibe Coders

1. **Morning Planning**: Always start with `vibe-logger weekly-report`
2. **Session Breaks**: Use `vibe-logger session-summary` for quick efficiency checks
3. **Quota Management**: Set up alerts at 70% and 85% of weekly limits
4. **Emergency Prep**: Always have `vibe-logger emergency-save` ready
5. **Calendar Sync**: Review `vibe-logger schedule-week` every Sunday

---

**Remember**: With weekly rate limits, precision beats speed. This logging system gives Vibe Coders the foresight to maximize value from every token and every session.

*"The best developers don't just code fast—they code strategically."* 🚀